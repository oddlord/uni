\chapter{Da AlViE ad HTML5}
	\label{chap:alvieHTML5}
	Concludiamo questo studio analizzando nel dettaglio come avviene l'esportazione delle visualizzazioni di AlViE in HTML5.\\
	\\
	Come abbiamo visto nel Capitolo \ref{chap:alvie}, AlViE memorizza le visualizzazioni in appositi file XML, che definiscono ogni singolo passo di visualizzazione. Inoltre, sia nel caso in cui l'utente voglia generare una nuova visualizzazione, sia che voglia caricarne una vecchia, il sistema disporrà del file XML corrispondente. Quindi, osservando che la struttura di un file XML e di un file HTML sono molto simili tra loro, per implementare l'esportazione della visualizzazione in HTML5 si è deciso di definire un opportuno compilatore da XML ad HTML5. Questo compilatore XML-HTML5 avrà quindi il compito di tradurre le specifiche della visualizzazione nel file XML in comandi Canvas nel file HTML5.
	\section{Specifica HTML5 delle visualizzazioni}
		Analizziamo innanzitutto come viene strutturata la pagina di visualizzazione HTML5.\\
		\\
		Innanzitutto troviamo, come in tutte le pagine HTML, il tag \lstinline{<html>} che racchiude tutto il codice, e più precisamente i tag \lstinline{<head>} e \lstinline{<body>}. Il tag \lstinline{<head>} contiene il tag \lstinline{<script language="Javascript">}, che definisce appunto uno script in JavaScript, suddiviso in una serie di funzioni. Il tag \lstinline{<body>}, invece, contiene la definizione del Canvas e dei quattro bottoni di navigazione, indicandone l'origine dell'immagine utilizzata, le dimensioni e la funzione JavaScript associata al click su ognuno di essi.\\
		Tramite l'attributo \lstinline{onLoad="start();"}, del tag \lstinline{<body>}, viene richiamata la funzione JavaScript \lstinline{start()}, che permette l'inizializzazione della visualizzazione, disegnando sulla pagina il primo step.\\
		\\
		Ad ogni passo dell'algoritmo corrisponde una funzione JavaScript, della forma
		\begin{center}
			\lstinline{function stepX()},
		\end{center}
		dove X rappresenta il numero del passo di visualizzazione. La funzione relativa al primo passosarà quindi \lstinline{step0()}.\\
		A questo punto, tramite i quattro bottoni di navigazione in cima alla pagina, è possibile spostare la visualizzazione su un altro step. Al click di ogni bottone è associata una funzione JavaScript che calcola la funzione \lstinline{stepX()} da richiamare in base al numero di step attuale e al tipo di funzione richiamata. Le funzioni di navigazione sono quindi quattro, \lstinline{previous()}, \lstinline{next()}, \lstinline{first()} e \lstinline{last()}, che richiamano, rispettivamente, il passo precedente, il successivo, il primo o l'ultimo della visualizzazione. Nel caso in cui la visualizzazione sia sul primo step e venga richiamata la funzione \lstinline{previous()}, un messaggio d'errore verrà visualizzato dal browser. Analogamente per l'ultimo step. Le quattro funzioni di navigazione si avvalgono della funzione \lstinline{eval(str)} per richiamare la giusta funzione di step: questa funzione prende come input una stringa \lstinline{str} e richiama la funzione corrispondente a tale stringa.\\
		\\
		Ogni funzione \lstinline{stepX()} dovrà quindi occuparsi, innanzitutto, di ripulire l'area del Canvas dal passo precedente, tramite la funzione \lstinline{contesto.clearRect(0, 0, canvas.width, canvas.height)}. Dopo aver ripulito l'intero Canvas, verranno richiamate opportune primitive grafiche per produrre il disegno vero e proprio, comprensivo di strutture dati, pseudocodice e messaggio.\\
		Viene anche definita una funzione \lstinline{writeMessage(contesto, messaggio, X)}, con X punto di partenza sull'asse delle ascisse, per poter disegnare sul Canvas il messaggio. È necessaria una funzione a sé stante, in quanto i messaggi più lunghi devono essere spezzati in più linee, che è appunto ciò di cui si occupa la funzione. In caso contrario, messaggi troppo lunghi produrrebbero un'area del Canvas esageratamente lunga, rendendone scomoda la lettura.
	\section{Compilatore XML-HTML5}
		Il compilatore XML-HTML5 che è stato scritto per questo progetto traduce linea per linea il contenuto del file XML della visualizzazione in comandi Canvas da scrivere nella pagina HTML. Vengono quindi aperti due stream (o flussi) dal sistema: uno in lettura dal file XML ed uno in scrittura sul file HTML. L'intero processo di traduzione del file XML della visualizzazione si divide in due fasi ben distinte: una fase di parsing ed una fase di compilazione.\\
		\subsection{Fase di parsing}
			La prima fase, quella di parsing del file XML, consiste nell'analizzare il file XML della visualizzazione ed estrarne le informazioni contenute, organizzandole in oggetti dalla struttura nota e facilmente accessibili.\\
			Il parser utilizzato in questo studio viene detto \textit{Digester}, ed è sviluppato e distribuito dalla Apache. Gli oggetti in cui archiviare le informazioni estratte dal file XML vengono invece dette \textit{Bean}. Appositi Digester si occuperanno di ogni tag incontrato, incapsulando le informazioni estratte in oggetto Bean relativo al tag designato per il parsing. Ogni Digester dovrà essere inizializzato con apposite regole che gli indichino come estrarre e strutturare gli attributi di ogni tag incontrato. I Bean, poi, conterranno le informazioni estratte, fornendo anche metodi accessori per ottenere i valori dei vari attributi in un secondo momento.\\
			Gli oggetti Bean sono organizzati secondo una struttura gerarchica, rispecchiando l'organizzazione del file XML: ogni StepBean contiene, oltre ai suoi attributi, anche un insieme di StructureBean, relativi alle strutture contenute nel tag \lstinline{<step>}; analogamente ogni StructureBean conterrà il Bean del messaggio ed i Bean della struttura dati e della struttura dati grafica (ad esempio, ArrayBean e VisualArrayBean), e così via. L'insieme di tutti gli StepBean definisce, quindi, il file XML in modo completo, con tutte le informazioni in esso contenuto ben organizzare e facilmente accessibili.
		\subsection{Fase di compilazione}
			Una volta ottenuti tutti gli StepBean, inizia la compilazione vera e propria: i tag XML delle strutture dati hanno, all'interno del compilatore, una corrispettiva classe adibita alla gestione di quest'ultimo. Queste classi sono dette \textit{TagHandler}. Dopo aver correttamente riscritto, nel file HTML, le informazioni estratte dallo StepBean, il compilatore analizza tutti gli StructureBean in esso contenuti. Per ogni StructureBean viene creato un apposito TagHandler, implementando il design pattern del factory. Quindi, ogni TagHandler di struttura si specializza nella gestione di una specifica struttura dati, definendo le operazioni necessarie alla sua visualizzazione utilizzando comandi Canvas.\\
			\\
			Il gestore del tag \lstinline{<step>}, ad esempio, si occupa di definire la funzione \lstinline{stepX()} nel file HTML e inserire i comandi per la pulizia del Canvas. Quindi eseguirà un ciclo \textit{while} in cui invoca lo StructureHandlerFactory, finché non sono terminati gli StructureBean relativi a quello step. Una volta usciti dal ciclo \textit{while}, il gestore si occuperà di scrivere le informazioni necessarie alla stampa del messaggio di step sul file HTML.\\
			\\
			Una volta ottenute le informazioni necessarie dai Bean contenuti in ogni StructureBean, il gestore della struttura avrà finalmente tutte le informazioni necessarie per ricavare le primitive grafiche che produrranno il disegno nella pagina HTML.\\
			Spesso però, le informazioni raccolte dai singoli elementi non definiscono in maniera esplicita le operazione grafiche necessarie. Nella specifica XML di un vettore, ad esempio, vengono indicate le coordinate d'origine dell'intero vettore, non di ogni singolo elemento. Tutti questi dati, \textit{impliciti} nella specifica XML, dovranno quindi essere calcolati, tramite apposite funzioni, per poter disegnare nella pagina i singoli elementi grafici che compongono il disegno finale.
		\subsection{Pesantezza della pagina vs. pesantezza di compilazione}
			Ha senso, a questo punto, domandarsi a chi spetta l'onere di calcolare tutti questi dati impliciti. Le scelte sono chiaramente due: il calcolo può essere fatto \textit{a monte}, ovvero dal compilatore, oppure \textit{a valle}, cioè dal browser HTML che visualizza la pagina.\\
			\\
			Se viene scelto di effettuare questi calcoli lato browser, si avrà sicuramente una compilazione più veloce. Il compito del browser verrà, invece, appesantito, rendendosi necessaria l'occupazione di risorse per il calcolo di questi dati impliciti. Questo approccio permette, tuttavia, di riutilizzare il codice necessario alla visualizzazione di stessi oggetti grafici. Può, ad esempio, essere definita una funzione che disegni un quadrato, una che disegni un vettore o una che disegni un intero grafo. Se in una visualizzazione appaiono, ad esempio, più vettori, la visualizzazione di ogni nuovo vettore si tradurrà, nella pagina HTML, in un'unica invocazione della funzione adibita a disegnare vettori.\\
			Quindi questa scelta velocizza il compilatore, rallenta il browser e alleggerisce la pagina.\\
			\\
			Scegliere, invece, di effettuare i calcoli \textit{a monte} implica, chiaramente, un maggio costo computazionale del processo di compilazione. D'altro canto, la pagina HTML verrà alleggerita, per quanto riguarda il costo computazionale, in quanto il compilatore potrà scrivervi direttamente le primitive grafiche necessarie, senza bisogno di ulteriori calcoli. Tuttavia, utilizzare primitive grafiche, all'interno della pagina HTML, significa essere costretti a ripetere il codice necessario al disegno di uno stesso oggetto. Se la visualizzazione deve, ad esempio, disegnare più vettori, ognuno dei quali disegnato da (indicativamente) 10 primitive grafiche, si avranno nella pagina HTML 10 linee di codice per ogni nuovo vettore da visualizzare. Si vede che, rispetto al caso precedente, le dimensioni della pagina risultano aumentate di circa un fattore $m$, dove con $m$ si indica il numero medio di primitive necessarie alla visualizzazione di un oggetto grafico elementare.\\
			Riassumento: questa scelta ci porta ad una compilazione più lenta, una visualizzazione più veloce ed una pagina Web più pesante.\\
			\\
			Non esiste, come si può vedere, una scelta ottimale: le due strade presentano sia pregi che difetti. Quale scelta intraprendere dipende allora dal tipo di applicazione per cui si è reso necessario il compilatore.\\
			Nel nostro caso, ovvero la visualizzazione di algoritmi sul Web, si è ritenuto più efficiente optare per i calcoli dei dati \textbf{a monte}. Si è ipotizzato, infatti, che siano molte di più le volte in cui una visualizzazione venga eseguita (ovvero visualizzare i vari step che la compongono), rispetto alle volte in cui essa possa venir creata (tramite il compilatore) o caricata tramite Internet. Le dimensioni della pagina HTML sono infatti inversamente proporzionali al tempo necessario per il suo download.\\
			Ricapitolando, abbiamo optato, durante lo sviluppo di questo progetto, per una compilazione ed un tempo di download della pagina più lenti, a favore di visualizzazioni più rapide. Questo dilemma risulta, tuttavia, puramente teorico: nella pratica, la scelta di questo metodo al posto dell'altro si riduce ad una manciata di KB in più nella dimensione delle pagine e a pochi millisecondi in più di compilazione. Anche la velocità di visualizzazione da parte del browser risulta praticamente identica. Quindi la scelta è stata presa a livello puramente teorico, in quanto a livello pratico i due metodi sono di fatto indistinguibili.\\
			\\
			Mostriamo, a titolo d'esempio, la funzione che calcola le primitive per il disegno di un cerchio, definita all'interno del compilatore di AlViE:
			\lstinputlisting[language=java]{code/circle.java}
			Si può vedere, in quest'esempio, che il compilatore si occupa di calcolare alcuni dettagli, come il raggio del cerchio o la dimensione del testo all'interno, per poi scrivere sulla pagina HTML le primitive grafiche corrispondenti, come \lstinline{ctx.arc()}.