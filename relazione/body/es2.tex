% !TeX spellcheck = it_IT
\section*{Esercizio 2: Scheduler di processi}

    \subsection*{Descrizione ad alto livello}
    
        Come per l'esercizio precedente, descriviamo il funzionamento generale del programma tramite una descrizione at alto livello.
        
        Essendo questo esercizio, rispetto al precedente, molto più complesso, la descrizione ad alto livello del codice trascurerà alcuni dettagli meno interessanti, come la stampa su consolle di messaggi di servizio, e si concentrerà invece su aspetti più importanti del codice, per rendere la lettura più chiara e scorrevole.
        
        L'idea generale è quella di costruire e gestire due liste doppiamente concatenate, una corrispondente alla politica di scheduling A (su priorità) ed una corrispondente alla politica B (su esecuzioni rimanenti). Ad ogni task corrisponderà quindi un record, opportunamente allocato in memoria in modo dinamico, composto da una serie di ``campi''. Oltre ai campi caratteristici del task, come ID, nome, ecc., questo record conterrà anche quattro puntatori ad altri task, ovvero i puntatori al precedente e successivo sia per la politica A che per la B. Servirà quindi mantenere, in ogni momento, due puntatori, che rappresentano i puntatori d'inizio delle due liste concatenate, e la politica di scheduling attuale. Per semplicità di esposizione, nello pseudocodice rappresenteremo l'accesso ai campi di ogni record con una sintassi simile all'accesso ai campi di un oggetto (ovvero l'istanza di una classe): questa è solamente una scorciatoia a livello di esposizione per semplificare la lettura dello pseudocodice e non vuol dare l'idea che si stanno implementando classi ed oggetti. Le code, inoltre, saranno implementate al contrario, ovvero gli elementi puntati dai puntatori d'inizio sono di fatto gli elementi in fondo alle due code. Il perché di questa scelta verrà commentato in seguito.
        
        Detto questo, iniziamo col vedere, qui di seguito, la descrizione ad alto livello del segmento di codice \pseudo{main()}, punto d'entrata del programma:
        
        \begin{center}
           	\begin{lstlisting}[language=pseudo, gobble=14]
                main(){
                    sched = 'a'
                    start_A = null
                    start_B = null
                    
                    while(true){
                        com = read_int("Inserire un comando: ")
                        switch(com){
                            case 1:
                                start_A, start_B = insert_task(start_A, start_B)
                            case 2:
                                start_A, start_B = run_first(sched, start_A, start_B)
                            case 3:
                                start_A, start_B = run_id(start_A, start_B)
                            case 4:
                                start_A, start_B = delete_id(start_A, start_B)
                            case 5:
                                start_A, start_B = change_prio(start_A, start_B)
                            case 6:
                                sched = change_sched(sched)
                            case 7:
                                print("Terminazione del programma.")
                                exit()
                            default:
                                print("Menu: ...")
                        }
                        
                        if(sched == 'a'){ (*@\label{lst:print_queue_start}@*)
                            i = start_A
                        } else {
                            i = start_B
                        }
                        delim = "+----+-----------+-----------+-------------------+"
                        header = "| ID | PRIORITA' | NOME TASK | ESECUZ. RIMANENTI |"
                        println(delim)
                        println(header)
                        println(delim)
                        if(i == null){
                            println("|                  Coda vuota!                   |")
                            println(delim)
                            continue
                        }
                        while(i != null){
                            print("/ ")
                            id = i.id
                            if (id <= 9){
                                print("  " + id)
                            } else {
                                print(" " + id)
                            }
                            print(" /     " + i.prio + "     / " + i.name + "  /        ")
                            cycles = i.cycles
                            if(cycles <= 9){
                                print(" " + cycles)
                            } else {
                                print(cycles)
                            }
                            println("         /")
                            println(delim)
                            if(sched == 'a'){
                                i = i.next_A
                            } else {
                                i = i.next_B
                            }
                        }
                    }
                }\end{lstlisting}
        \end{center}
        
        La prima cosa che viene fatta è inizializzare i due puntatori iniziali a \pseudo{null} e la politica di scheduling ad A. Quindi si inizia un ciclo nel quale ad ogni passo viene chiesto un comando tramite l'inserimento di un intero da input: a questo punto, a seconda dell'intero inserito, viene eseguita l'operazione corrispondente, passandogli i parametri necessari e catturando i valori di ritorno. Ad esempio, la funzione corrispondente al comando $1$, ovvero l'inserimento di un nuovo task, prende come parametri i puntatori d'inizio attuali e restituisce una coppia di puntatori d'inizio aggiornati. Se il comando è il $7$, allora si procede all'uscita dal programma senza invocare procedure, mentre in tutti gli altri casi (ad esempio inserendo altri interi, caratteri, stringhe o semplicemente premendo Invio) viene stampato il menu dove vengono descritti i vari comandi disponibili.
        
        Una volta eseguita la funzione richiesta, vengono eseguite le istruzioni per la stampa della coda (dalla riga \ref{lst:print_queue_start} dello pseudocodice). Dapprima, viene inizializzato un puntatore, che servirà a scorrere la coda a seconda della politica di scheduling attuale, e verrà stampata l'intestazione della tabella. In caso di coda vuota, verrà stampato un messaggio all'interno della tabella e si tornerà alla richiesta di selezione di un comando. In caso contrario inizierà invece un ciclo su tutti gli elementi della lista, da quello in fondo a quello in testa. Per ogni elemento viene stampata una riga nella tabella, contenente tutte le informazioni del task, estraendole dal record. Tutti gli spazi aggiuntivi che si vedono nelle varie stringhe che vengono stampate servono a rendere i campi della tabella allineati. Inoltre, su due campi, l'ID e le esecuzioni rimanenti, viene controllato se il numero è a due cifre oppure una sola, in modo da stampare un numero corretto di spazi per allineare il valore a destra (in questo caso, mentre per le esecuzioni rimanenti siamo sicuri di avere al massimo un numero di due cifre, per l'ID non possiamo esserne certi, quindi assumiamo che l'ID di un task arrivi fino a 99, altrimenti la tabella verrà non allineata). Al termine del ciclo, verrà quindi caricato il task seguente nella lista, a seconda della politica di scheduling.
        
        Vediamo adesso, una per una, le implementazioni ad alto livello dei vari comandi, iniziando con l'inserimento di un nuovo task.
        
        \begin{center}
           	\begin{lstlisting}[language=pseudo, gobble=14]
                insert_task(start_A, start_B){
                    task = new_task() // alloca spazio sufficiente con sbrk
                    task.prev_A = null
                    task.prev_B = null
                    while(true){
                        id = read_int("Inserire l'ID: ")
                        if(start_A == null){
                            task.id = id
                            break
                        }
                        duplicate_task = find_id(id, start_A)
                        if(duplicate_task == null){
                            task.id = id
                            break
                        }
                        println("Task con ID " + id + "già presente.")
                    }
                    name = read_string("Inserire il nome: ")
                    task.name = name // inserisce soltanto i primo 8 caratteri della stringa inserita
                    while(true){
                        prio = read_int("Inserire la priorità: ")
                        if(prio >= 0 AND prio <= 9){
                            task.prio = prio
                            break
                        }
                    }
                    while(true){
                        cycles = read_int("Inserire i cicli di esecuzione: ")
                        if(cycles >= 1 AND cycles <= 99){
                            task.cycles = cycles
                            break
                        }
                    }
                    task.next_A = null
                    task.next_B = null
                    
                    start_A, start_B = insert(task, start_A, start_B)
                    
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        La funzione \pseudo{insert_task()} riceve come argomenti i due puntatori d'inizio, mentre la politica di scheduling attuale non serve in quanto il task dovrà essere inserito in entrambe le liste indifferentemente dalla politica attuale. Per prima cosa viene allocato spazio per il nuovo task (la pseudoistruzione \pseudo{new_task()} corrisponde di fatto ad una chiamata SBRK di 36 byte). Quindi si procede a chiedere da input i valori dei vari campi per poi inserirli all'interno del record del nuovo task. Se la coda è vuota, l'ID viene inserito automaticamente, altrimenti si controlla che non sia già presente un task con lo stesso ID (tramite la funzione \pseudo{find_id()}, di cui vedremo a breve l'implementazione): se il risultato è positivo, allora si chiede un nuovo ID, altrimenti si può salvare l'ID selezionato all'interno del record. Per quanto riguarda priorità e cicli d'esecuzione viene fatto un controllo simile: si richiede infatti l'inserimento di una priorità tra 0 e 9 e di cicli di esecuzioni tra 1 e 99. I puntatori a precedenti e successivi, invece, vengono inizializzati a \pseudo{null}, in quanto il task, di fatto, non è ancora inserito nelle liste.
        
        Per inserire il task nelle due code si invoca quindi la funzione \pseudo{insert()} (che descriveremo a breve) passandogli come parametri il puntatore al task appena creato e i due puntatori d'inizio. Il risultato sarà una coppia di puntatori d'inizio aggiornati, che la funzione \pseudo{insert_task()} potrà quindi restituire, terminando la sua esecuzione.
        
        Vediamo, di seguito, l'implementazione della funzione ausiliaria \pseudo{find_id()}:
        
        \begin{center}
           	\begin{lstlisting}[language=pseudo, gobble=14]
                find_id(id, start_A){
                    task = null
                    i = start_A
                    while(i != null){
                        if(id = i.id){
                            task = i
                            break
                        }
                        i = i.next_A
                    }
                    return task
                }\end{lstlisting}
        \end{center}
        
        La funzione \pseudo{find_id()} prende in input un ID ed il puntatore d'inizio della lista A e restituisce il puntatore al task con ID indicato se presente nelle code, \pseudo{null} altrimenti. Dal momento che, per come abbiamo implementato \pseudo{insert_task()}, ogni ID è unico nelle code e che gli elementi nelle due code sono esattamente gli stessi (a meno dell'ordinamento), scorrere la lista A o la B è indifferente ai fini di trovare un task con ID specificato. La funzione è molto semplice: si inizializza il puntatore al task da trovare a \pseudo{null} e quindi si scorre la lista tramite un ciclo dal quale si può uscire soltanto una volta trovato un task con ID corrispondente o una volta terminata la lista. Se il task è stato effettivamente trovato, allora verrà restituito il suo puntatore, altrimenti \pseudo{null}. Questa funzione è stata implementata a parte in quanto verrà riutilizzata in altri punti del codice.
        
        Parliamo anche l'implementazione della seconda funzione ausiliaria vista fin'ora, ovvero \pseudo{insert()}. La funzione \pseudo{insert()} è una funzione molto complessa ed in qualche modo rappresenta il cuore di tutto il programma. L'implementazione di questa funzione è caratterizzata da alcuni costrutti molto particolari, possibili soltanto grazie alle istruzioni di salto messe a disposizione dal linguaggio assembly, la cui conversione in pseudocodice di alto livello è molto complessa, se non impossibile, da rendere pur mantenendo un certo livello di chiarezza e leggibilità. Per queste ragioni commenteremo l'implementazione di questa funzione soltanto a livello testuale e senza l'ausilio di pseudocodice, che renderebbe soltanto le cose più difficili da comprendere.
        
        La funzione \pseudo{insert()} è una funzione ausiliare che prende in input il puntatore al task che si vuole inserire nelle due liste ed i puntatori d'inizio delle liste A e B. È quindi una funzione generica per l'inserimento di un task nelle due liste che verrà utilizzata più volte all'interno del programma.
        
        La funzione controlla innanzitutto se le due liste sono vuote (puntatori d'inizio a \pseudo{null}): in questo caso fa puntare i due puntatori d'inizio al task da inserire e li restituisce. In caso contrario, inizia un primo ciclo, dedicato all'inserimento nella lista A, ovvero alla coda relativa allo scheduling su priorità. Il ciclo procede scorrendo gli elementi della lista A fin tanto che vengono trovati task con priorità maggiore del task da inserire. Se, così facendo, si raggiunge la fine della lista, allora il task viene inserito come ultimo. Se durante lo scorrimento si trova invece un task con priorità uguale al task da inserire, inizia allora un secondo ciclo, più interno, che scorre gli elementi confrontando le loro esecuzioni rimanenti: finché si trovano task con meno esecuzioni (e stessa priorità) del task da inserire, si va avanti, altrimenti si inserisce il task (ovvero non appena si trova una priorità minore o delle esecuzioni rimanenti maggiori o uguali). Se invece, durante il ciclo principale, si raggiunge direttamente un task con priorità minore, allora il task è da inserire tra quel task trovato ed il suo precedente (o come primo della lista se quello era il primo). L'inserimento effettivo del task nella lista A prevede quindi, una volta individuato il punto preciso nella lista in cui inserirlo, di aggiornare i puntatori \pseudo{prev_A} e \pseudo{next_A} del task da inserire e del task prevedente e successivo al punto in cui si vuole inserire (in più, se il task è da inserire come primo, allora si aggiorna anche il puntatore d'inizio A).
        
        Una volta inserito correttamente il task all'interno della lista A, viene fatto un ciclo del tutto analogo, ed in un certo senso speculare, per l'inserimento nella lista B. Le uniche differenze sono l'utilizzo dei vari puntatori al precedente/successivo, che quindi saranno \pseudo{prev_B} e \pseudo{next_B}, ed i criteri di scorrimento della lista: se prima si cercava il primo task con priorità minore di quello da inserire, adesso si cerca invece il primo task con numero di esecuzioni rimanenti strettamente maggiore del task da inserire. Analogamente, se viene trovato un task con le stesse esecuzioni rimanenti, allora inizia un ciclo più interno, in cui si cerca il primo task con priorità minore o uguale (o, sempre, con esecuzioni rimanenti maggiori).
        
        Al termine di questo secondo ciclo, il task risulterà correttamente inserito nelle due liste, trovandosi, per entrambe, esattamente nel suo punto finale, ovvero ordinato secondo la politica di scheduling su priorità (nella lista A) o su esecuzioni rimanenti (lista B). La funzione \pseudo{insert()} terminerà quindi restituendo i puntatori d'inizio delle due liste, eventualmente aggiornati.
        
        Passiamo all'implementazione del secondo comando, ovvero l'esecuzione del task in testa alla coda.
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                run_first(sched, start_A, start_B){
                    if(sched == 'a'){
                        i = start_A
                    } else {
                        i = start_B
                    }
                    
                    if(i == null){
                        println("Coda vuota!")
                        return start_A, start_B
                    }
                    
                    while(true){
                        if(sched == 'a'){
                            next = i.next_A
                        } else {
                            next = i.next_B
                        }
                        if(next == null){
                            break
                        }
                        i = next
                    }
                    
                    start_A, start_B = run(i, start_A, start_B)
                    
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        La funzione che implementa il secondo comando, \pseudo{run_first()}, prende in input la politica di scheduling attuale ed i due puntatori d'inizio, per poi restituire i due puntatori d'inizio, eventualmente aggiornati, dopo aver eseguito il task in cima alla coda. Questa funzione utilizza un puntatore, \pseudo{i}, per scorrere la coda, a seconda della politica attualmente selezionata. Il puntatore \pseudo{i} viene inizializzato al puntatore d'inizio corrispondente alla politica attuale, quindi viene effettuato un ciclo all'interno del quale si scorrono tutti i task della lista (A o B, a seconda della politica di scheduling) per fermarsi soltanto una volta trovato il primo task che non ha successore, ovvero l'ultimo della lista. Avendo implementato le code ``al contrario'', l'elemento in fondo alla lista corrisponde all'elemento in testa alla coda, ovvero il task che vogliamo eseguire. Una volta individuato il task, si invoca quindi una funzione ausiliare, \pseudo{run()}, che si occupa di eseguire il task specificato come parametro e restituire i puntatori d'inizio aggiornati. Infine, \pseudo{run_first()} potrà restituire i nuovi puntatori d'inizio.
        
        La funzione ausiliaria \pseudo{run()} è una funzione che serve ad eseguire un task specifico, aggiornando le liste di conseguenza. È stato utile scrivere \pseudo{run()} come funzione a sé stante in quanto essa verrà riutilizzata per l'implementazione del terzo comando, ovvero l'esecuzione di un task specifico. Infatti, pensandoci bene, il secondo e terzo comando fanno più o meno la stessa cosa (eseguire un task): l'unica cosa che cambia è come viene individuato il task da eseguire, ma il resto delle operazioni rimane identico. Quindi si è deciso di implementare l'esecuzione di un task generico come funzione ausiliaria a parte (\pseudo{run()}, appunto) e di ridurre le implementazioni dei comandi secondo e terzo alla semplice individuazione del task da eseguire (uno cercando quello in testa, l'altro cercando quello con un ID specifico), per poi richiamare entrambi la funzione \pseudo{run()} sul task individuato.
        
        Lo pseudocodice dell'implementazione di \pseudo{run()}  è mostrata di seguito:
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                run(task, start_A, start_B){
                    task.cycles = task.cycles - 1
                    start_A, start_B = detach(task, start_A, start_B)
                    if(task.cycles > 0){
                        start_A, start_B = insert(task, start_A, start_B)
                    }
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        Quello che fa \pseudo{run()} è molto semplice. Innanzitutto aggiorna il numero di esecuzioni rimanenti del task, decrementandolo. Quindi invoca una funzione ausiliaria, \pseudo{detach()}, che serve a ``staccare'' il task selezionato da entrambe le liste. A questo punto, se le esecuzioni rimanenti non hanno raggiunto lo $0$, il task viene reinserito nelle liste, eventualmente in una posizione diversa da quella precedente. Questa tecnica, rimuovere un task e reinserirlo, permette di riutilizzare in maniera intelligente il codice scritto per \pseudo{insert()} in modo da mantenere le liste sempre aggiornate ogni qual volta si effettua una modifica ad un task (in particolare, alla sua priorità o alle sue esecuzioni rimanenti). Nel caso in cui le esecuzioni rimanenti abbiano raggiunto lo $0$, il task verrà quindi eliminato a livello logico dalle liste, ovvero la memoria allocata per il record del task non verrà deallocata, ma verranno semplicemente eliminati i collegamenti al task da entrambe le liste, rendendolo di fatto irraggiungibile e, quindi, come se non esistesse.
        
        Vediamo l'implementazione di \pseudo{detach()}:
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                detach(task, start_A, start_B){
                    if(start_A.next_A == null){
                        start_A = null
                        start_B = null
                    } else {
                        prev = task.prev_A
                        next = task.next_A
                        if(prev == null){
                            start_A = next
                            next.prev_A = null
                        } else if(next == null){
                            prev.next_A = null
                        } else {
                            prev.next_A = next
                            next.prev_A = prev
                        }
                        
                        prev = task.prev_B
                        next = task.next_B
                        if(prev == null){
                            start_B = next
                            next.prev_B = null
                        } else if(next == null){
                            prev.next_B = null
                        } else {
                            prev.next_B = next
                            next.prev_B = prev
                        }
                    }
                    
                    task.prev_A = null
                    task.next_A = null
                    task.prev_B = null
                    task.next_B = null
                    
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        Quello che fa la funzione ausiliaria \pseudo{detach()} è molto semplice. Innanzitutto controlla se l'elemento da rimuovere è l'unico della lista, nel qual caso imposta semplicemente i puntatori d'inizio a \pseudo{null}. Altrimenti, carica il task precedente ed il successivo del task da rimuovere (prima nella lista A, poi nella B) e li collega tra loro, facendo anche controlli nel caso in cui il task da rimuovere fosse stato il primo (nel qual caso aggiorna anche il puntatore d'inizio) oppure l'ultimo. Infine imposta tutti i puntatori del task a \pseudo{null} (quest'ultima operazione non sarebbe necessaria, viene fatta più per un motivo correttezza e consistenza).
        
        Con \pseudo{detach()} abbiamo terminato la descrizione delle funzioni ausiliarie implementate nel codice del programma, quindi possiamo passare a descrivere le funzioni dei comandi rimanenti. Di seguito, la funzione \pseudo{run_id()}, che implementa il comando per l'esecuzione di un task specifico:
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                run_id(start_A, start_B){
                    if(start_A == null){
                        println("Coda vuota!")
                        return start_A, start_B
                    }
                    
                    while(true){
                        id = read_int("Inserire l'ID del task da eseguire: ")
                        task = find_id(id, start_A)
                        if(task == null){
                            println("Task con ID " + id + "non trovato.")
                        } else {
                            break
                        }
                    }
                    
                    start_A, start_B = run(task, start_A, start_B)
                    
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        Vedendo la descrizione di \pseudo{run_id()} possiamo subito notare come l'aver implementato le funzioni ausiliarie di cui abbiamo parlato prima abbia semplificato enormemente l'implementazione di tutte le altre funzioni. \pseudo{run_id()}, infatti, si limita a chiedere all'utente un ID da linea di comando finché non viene trovato nelle liste un task con l'ID specificato (funzione ausiliaria \pseudo{find_id()}). Quindi, una volta recuperato il task che si vuole eseguire, basterà passarlo alla funzione ausiliaria \pseudo{run()} per ottenere i risultati prefissati.
        
        Di seguito, la descrizione ad alto livello della funzione per l'eliminazione di un task con ID specificato dalla coda:
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                delete_id(start_A, start_B){
                    if(start_A == null){
                        println("Coda vuota!")
                        return start_A, start_B
                    }
                    
                    while(true){
                        id = read_int("Inserire l'ID del task da eliminare: ")
                        task = find_id(id, start_A)
                        if(task == null){
                            println("Task con ID " + id + "non trovato.")
                        } else {
                            break
                        }
                    }
                    
                    start_A, start_B = detach(task, start_A, start_B)
                    
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        Nuovamente, possiamo vedere quanto le funzioni ausiliarie che abbiamo incluso rendano l'implementazione più semplice. La funzione \pseudo{delete_id()}, infatti, è strutturata esattamente come \pseudo{run_id()}, con l'unica differenza che, una volta trovato il task con ID specificato da input, anziché passarlo come parametro a \pseudo{run()} lo passa come parametro a \pseudo{detach()}, ottenendo, di fatto, l'eliminazione logica del task da entrambe le liste.
        
        Il prossimo frammento di pseudocodice rappresenta invece l'implementazione della funzione \pseudo{change_prio()}, corrispondente al comando 5, che cambia la priorità di un task con ID specificato:
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                change_prio(start_A, start_B){
                    if(start_A == null){
                        println("Coda vuota!")
                        return start_A, start_B
                    }
                    
                    while(true){
                        id = read_int("Inserire l'ID del task da modificare: ")
                        task = find_id(id, start_A)
                        if(task == null){
                            println("Task con ID " + id + "non trovato.")
                        } else {
                            break
                        }
                    }
                    while(true){
                        prio = read_int("Inserire la nuova priorità: ")
                        if(prio >= 0 AND prio <= 9){
                            task.prio = prio
                            break
                        }
                    }
                    
                    start_A, start_B = detach(task, start_A, start_B)
                    start_A, start_B = insert(task, start_A, start_B)
                    
                    return start_A, start_B
                }\end{lstlisting}
        \end{center}
        
        Essendo \pseudo{change_prio()} una funzione che, come le due precedenti, si basa sull'eseguire una certa operazione su un task con ID specificato, rispetto alle funzioni \pseudo{run_id()} e \pseudo{delete_id()} cambia soltanto la parte centrale, che rappresenta l'operazione eseguita sul task individuato. In questo caso, una volta individuato il task richiesto, viene chiesto all'utente di inserire una priorità (compresa tra $0$ e $9$, come visto prima in \pseudo{insert_task()}) che verrà impostata come nuova priorità del task. È necessario, quindi, aggiornare la posizione del task nelle due liste, in quanto la modifica della priorità potrebbe aver cambiato l'ordine relativo dei task. Per fare questo, si rimuove il task dalle liste, invocando \pseudo{detach()}, e quindi lo si reinserisce invocando \pseudo{insert()}, che si occuperà di inserirlo nella posizione corretta in entrambe le liste tenendo conto della priorità aggiornata.
        
        Infine, vediamo l'implementazione della funzione che permette di passare da una politica di scheduling all'altra:
        
        \begin{center}
            \begin{lstlisting}[language=pseudo, gobble=14]
                change_sched(old_sched){
                    if(old_sched == 'a'){
                        new_sched = 'b'
                    } else {
                        new_sched = 'a'
                    }
                    return new_sched
                }\end{lstlisting}
        \end{center}
        
        Quest'ultima funzione, molto semplice, controlla semplicemente qual è la politica di scheduling attuale e restituisce l'altra politica, la quale, all'interno del \pseudo{main()}, verrà salvata come politica di scheduling attuale.
    
    \subsection*{Motivazione delle scelte implementative}
    
        Discutiamo, adesso, alcune scelte implementative fatte.
        
        La scelta implementativa forse più importate è quella di aver implementato le code tramite liste mantenute sempre ordinate. La principale alternativa, in questo senso, sarebbe stata quella di mantenere una sola lista, senza un ordine preciso, andando a ricavare l'ordine corretto ogni qual volta venga invocata una funzione per la quale l'ordine è discriminante, come l'esecuzione del primo task o la stampa della coda. Se avessimo implementato questa alternativa, alcune funzioni sarebbero risultate molto più semplici: la funzione \pseudo{insert()}, per essere più specifici, sarebbe costata un $\mathcal{O}(1)$, in quanto sarebbe bastato inserire il task in una posizione qualsiasi (ad esempio la prima) della lista. Di conseguenza, tutte le funzioni che invocano \pseudo{insert()}, come \pseudo{insert_task()} o \pseudo{run()}, sarebbero a loro volta risultate molto più semplici, sia a livello implementativo che computazionale, non dovendo preoccuparsi di mantenere l'ordine nella lista. Il problema con questa implementazione sorge al momento in cui è necessario ricavare l'ordine relativo dei task, ovvero durante la funzione 
    
    \subsection*{Simulazioni}
    
    \subsection*{Codice MIPS}
