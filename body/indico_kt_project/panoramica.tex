\chapter{KT Project: una panoramica} \label{chap:panoramica}

	In questo capitolo introdurremo i principali obiettivi del Progetto KT per Indico in modo da dare una panoramica generale dei sottoprogetti di cui il progetto principale è composto. Inoltre verranno esposti i principali strumenti e linguaggi utilizzati durante lo sviluppo del progetto.
	
	\section{Progetti principali} \label{sec:p;progetti_principali}
    	
    	Il progetto finanziato dal gruppo \ac{KT} per Indico, oggetto principale del programma di Technical Student a cui ha partecipato il sottoscritto, è nato come co-progetto tra i gruppi \ac{IT} e \ac{KT}. L'obiettivo principale di questo progetto è quello di migliorare la visibilità e l'impatto di Indico in tutto il mondo, in particolare al di fuori della comunità \acr{HEP}, all'interno della quale Indico si è già ampiamente affermato.
    	
    	Come si è già accennato nel Capitolo \ref{chap:CERN}, il concetto di \ac{KT} si basa sull'idea della diffusione e condivisione della conoscenza e degli strumenti necessari per ottenerla. L'idea alla base del progetto era quindi quella di modificare e migliorare il software Indico in modo da permettere una miglior diffusione dello stesso nel mondo. Per fare questo, il KT Project si era prefissato tre obiettivi generali da raggiungere:
    	
    	\begin{itemize}
        	\item rendere Indico più accessibile agli utenti
        	\item rendere Indico più semplice da utilizzare e personalizzare
        	\item rendere Indico, in generale, più moderno e visivamente ``attraente''
    	\end{itemize}
    	
    	Gli obiettivi prefissati col Progetto KT erano quindi molto ampi e generali e, come ci può immaginare, anche piuttosto complessi da mettere in pratica. Per questa ragione il progetto che è stato assegnato al sottoscritto non era che il primo di una serie di progetti, finanziati dal gruppo \ac{KT}, al fine di migliorare l'impatto a livello mondiale del software Indico. Infatti, al durante il periodo di 14 mesi passati a Ginevra dal sottoscritto, erano stati approvati e finanziati già due progetti dal gruppo \ac{KT} per Indico: il primo, assegnato al sottoscritto, ed un secondo da assegnare ad un futuro membro del team Indico, molto probabilmente un altro Techical Student.
    	
    	Il primo Progetto KT per Indico è stato quindi pianificato e suddiviso in una serie di sotto-progetti, i quali dovevano essere terminati durante i 12 (poi diventati 14) mesi del programma Technical Student (si veda \cite{pedro:gist} per la prima stesura del progetto). Quattro di questi sotto-progetti sono risultati essere più importanti e complessi degli altri ed sono andati ad occupare gran parte del periodo di Technical Student. Di seguito ne parleremo brevemente per avere un'idea generale dei progetti principali del KT Project, mentre nei Capitoli successivi vedremo in dettaglio ognuno di essi.
    	
    	\subsection{Cloud Deployment} \label{subsec:p;pp;cloud}
    	
        	La prima fase del Progetto KT riguardava il Cloud Deployment di Indico, ovvero l'automatizzazione del processo di installazione e configurazione di Indico sia in ambiente cloud che in ambiente virtuale.
        	
        	Il progetto è durato circe un mese e mezzo, dal 23 Ottobre 2013 al 9 Dicembre 2013, ed ha portato alla scrittura di due script fabric, uno per la creazione di immagini virtuali ed uno di gestione remota, ed una recipe cloud-init, per il deployment su struttura cloud.
    	
    	\subsection{Distribuzione e Packaging} \label{subsec:p;pp:distribuzione}
    	
    	\subsection{Instance Tracker} \label{subsec:p;pp;instance_tracker}
    	
    	\subsection{Conference Customization Prototype} \label{subsec:p;pp;conference_customization_prototype}
    	
    \section{Strumenti e linguaggi} \label{sec:p;strumenti_linguaggi}
    
        Con questa ultima Sezione introduttiva, intendiamo fornire al lettore una serie di conoscenze e nozioni di base utili a capire il lavoro svolto con questo progetto. Indico infatti è composto da molti linguaggi diversi ed utilizza molti strumenti, sviluppati da terzi, senza i quali non potrebbe funzionare. È necessario quindi sapere quali sono e cosa fanno ognuno di questi strumenti, nonché essere a conoscenza dei linguaggi utilizzati.
        
        \subsection{Github} \label{subsec:p;sl;github}
    
        \subsection{Python} \label{subsec:p;sl;python}
        
            Un importante comando offerto da python è \python{.format()}: questa funzione sostituisce a degli speciali \textit{placeholder} (o segnaposti, in italiano), presenti nell'oggetto stringa sul quale viene eseguito, i valori associati ad ogni placeholder tramite un particolare dizionario, passato come unico argomento. I placeholder sono parole chiave, che identificano un parametro in modo univoco, racchiuse tra parentesi graffe. Il comando \python{.format()} funziona quindi come segue:
            
            \begin{center}
                \begin{lstlisting}[language=python, gobble=18]
                    data = {'first': 'Hodor', 'last': 'Hodor!'}
                    template = '{first} {last}'
                    result = template.format(**data)
                \end{lstlisting}
                \captionsetup{textformat=empty,labelformat=empty} \vspace{-2em}
                \captionof{lstlisting}[Comando \python{.format()} (esempio)]{Esempio del funzionamento del comando \python{.format()}.}
            \end{center}
            
            Il risultato salvato in \python{result} sarà quindi la stringa \python{'Hodor Hodor!'}.
        
        \subsection{Cloud-init} \label{subsec:p;sl;cloud-init}
        
            Cloud-init\footnote{\url{https://launchpad.net/cloud-init}} è uno degli strumenti più utilizzati per l'inizializzazione e configurazione di server cloud. Tramite la compilazione di alcune semplici impostazioni, l'utente sarà in grado di avviare un nuovo server cloud specificando una serie di azioni da eseguire in automatico durante il primo avvio, come ad esempio eseguire determinati script, copiare alcuni file da remoto, installare pacchetti ed applicazioni necessarie, e così via. Cloud-init è installato di default su molte distribuzioni Linux, come Ubuntu, Fedora, Debian, CentOS, ecc. \cite{cloud-init:readthedocs}
            
            In poche parole, Cloud-init è un modulo che viene eseguito all'avvio di una macchina virtuale e permette di specificare delle azioni da eseguire tramite un file detto \textit{user-data}. Un file di questo tipo, ovvero che permette di specificare una serie di azioni che verranno eseguite in automatico, viene detto \textit{recipe} (ovvero ``ricetta'' in inglese). Infatti si parla di \textit{cloud-init recipe} riferendosi ad una particolare configurazione da passare a cloud-init.
            
            Per utilizzare una cloud-init recipe, è sufficiente specificare il file \bash{user-data} generato quando si avvia il server sul cloud per la prima volta. Il comando da usare varia a seconda del Cloud Service Provider scelto. Per infrastrutture cloud basate su tecnologia OpenStack, ad esempio, è sufficiente eseguire il seguente comando da terminale:
            
            \begin{center}
                \begin{lstlisting}[language=bash, gobble=18]
                    $ nova boot --image ubuntu-cloudimage --flavor 1 --user-data user-data
                \end{lstlisting}
                \captionsetup{textformat=empty,labelformat=empty} \vspace{-2em}
                \captionof{lstlisting}[Boot con cloud-init (esempio OpenStack)]{Esempio di comando di boot con cloud-init per infrastrutture basate su OpenStack.}
            \end{center}
            
            Tramite il file \bash{user-data} è possibile passare al modulo cloud-init una serie di file in diversi formati supportati, tra i quali:
            
            \begin{itemize}
                \item file compresso in formato \bash{.gzip};
                \item file \acr{MIME} multiparti;
                \item bash script;
                \item file cloud-config.
            \end{itemize}
            
            In particolare, i file gzip possono essere utili per ridurre le dimensioni del file \bash{user-data}, essendo questo limitato a 16KB. I file \ac{MIME} multiparti sono tipi di file composti che servono a raggruppare altri file, dei tipi sopra citati, in un unico file. I file di script servono ad eseguire una serie di comandi subito dopo il primo boot, mentre i file cloud-config sono particolari file utilizzati per copiare file in remoto sulla macchina sul cloud oppure per installare tutti i pacchetti aggiuntivi necessari.
            
            Come vedremo nel Capitolo \ref{chap:cloud_deployment}, le recipe cloud-init sono state molto utili per la fase di Cloud Deployment di Indico.
                    
        \subsection{Fabric} \label{subsec:p;sl;fabric}
        
            Fabric è una ``libreria Python e uno strumento da linea di comando per rendere più semplice l'uso di \acr{SSH} per applicazioni di deployment o operazioni di amministrazione di sistema''. \cite{fabric:documentation}
            
        	\begin{figure}[h!]
        		\begin{center}
        			\includegraphics[scale=1]{fabric_logo.png}
        		\end{center}
        		\caption[Logo di Fabric]{Logo di Fabric.}
        		\label{fig:fabric_logo}
        	\end{figure}
            
            Fabric fornisce una serie di comandi per l'esecuzione sia locale che remota di comandi shell (normali o tramite \bash{sudo}), per l'upload o il download di file o per l'esecuzione di operazioni ausiliare, come richiedere un input all'utente o bloccare l'esecuzione di un'operazione in esecuzione.
            
            Uno script fabric è quindi un semplice script python, dove però si possono utilizzare tutti i comandi messi a disposizione da Fabric. Due comandi fabric molto importanti sono \python{local(cmd)} e \python{run(cmd)}. Entrambi i comandi eseguono il comando \python{cmd} passato come argomento come comando shell, l'unica differenza tra i due è che \python{local(cmd)} esegue \python{cmd} in locale, ovvero sulla macchina che sta eseguendo lo script fabric, mentre \python{run(cmd)} esegue \python{cmd} su una macchina remota, opportunamente specificata. Inoltre un altro comando molto utile è il comando \python{put(file, dest)} che permette di copiare il file \python{file}, che si trova sulla macchina locale, nella destinazione \python{dest} all'interno della macchina remota, quindi mimando il comportamento del comando \bash{scp} di bash.
            
            Per permettere una stesura più semplice e meno ridondante di uno script fabric, è possibile specificare alcune opzioni in un particolare dizionario, detto \textit{ambiente} e denotato dalla variabile \python{env}, in modo da non doverle ripetere ogni volta che si invoca un comando fabric. Ad esempio specificando un valore per il campo \python{env.hosts} possiamo definire una volta per tutte l'indirizzo di tutte le macchine remote su cui vogliamo eseguire i comandi passati a \python{run()}, senza dover stare a ripeterli inutilmente ogni volta.
            
            Ogni script fabric deve specificare delle operazioni, dette \textit{task}, che possono poi essere eseguite da linea di comando. Ogni task è una funzione python contrassegnata dal decoratore \python{@task}, che contrassegna le task (operazioni che possono essere eseguite dall'utente), da funzioni interne dello script.
            
            Per poter essere eseguito, uno script fabric deve essere chiamato \bash{fabfile.py}. Per eseguire quindi uno script fabric basta eseguire un comando della forma seguente:
            
            \begin{center}
                \begin{lstlisting}[language=bash, gobble=18]
                    $ fab task1 task2
                \end{lstlisting}
                \captionsetup{textformat=empty,labelformat=empty} \vspace{-2em}
                \captionof{lstlisting}[Esecuzione task fabric (esempio)]{Esempio dell'esecuzione di due task fabric.}
            \end{center}
            
            Un comando come quello appena mostrato esegue prima la task \bash{task1} e quindi \bash{task2} definite nel file \bash{fabfile.py}.
            
            Fabric verrà utilizzato, all'interno del progetto di Cloud Deployment, per la stesura sia di uno script per la creazione automatica di immagini virtuali, che di uno script per la gestione remota di macchine cloud.
        
        \subsection{QEMU e KVM} \label{subsec:p;sl;qemu_kvm}
        
            \acr{QEMU} è un emulatore e strumento di virtualizzazione open source. \acr{KVM} invece è anch'esso uno strumento di virtualizzazione e fornisce anche delle funzionalità di accelerazione hardware per sistemi Linux.
            
            \ac{QEMU} e \ac{KVM} possono essere utilizzati in congiunzione, tant'è che \ac{KVM} viene distribuito da anni assieme a \ac{QEMU}. Si potrebbe pensare di utilizzare soltanto uno di questi due strumenti per lavorare con macchine virtuali, tuttavia, anche se \ac{QEMU} fornisce un sistema di virtualizzazione completo e a se stante, per applicazioni pratiche è spesso necessario affiancargli \ac{KVM} per migliorarne le performance. D'altro canto, \ac{KVM} soltanto non fornisce tutte le funzionalità di un ambiente di virtualizzazione completo come \ac{QEMU}.
            
            \ac{QEMU} e \ac{KVM} sono stati utilizzati durante la fase di Cloud Deployment del progetto, ed in particolare nello script di creazione di immagini virtuali, come vedremo all'interno del Capitolo \ref{chap:cloud_deployment}.
            
            Per maggiori informazioni su \ac{QEMU} e \ac{KVM} si consultino \cite{kvm:wiki} e \cite{qemu:wiki}.
            
        \subsection{Virtualenv} \label{subsec:p;sl;virtualenv}
        
        \subsection{Requests} \label{subsec:p;sl;requests}
        
        \subsection{Twitter Bootstrap} \label{subsec:p;sl;twitter_bootstrap}
        
        \subsection{Flask} \label{subsec:p;sl;flask}
        
            TODO: parlare di \python{route()} e \python{render_template()}
        
        \subsection{Celery} \label{subsec:p;sl;celery}
        
        \subsection{PostgreSQL e SQLAlchemy} \label{subsec:p;sl;postgreSQL_SQLAlchemy}
        
        \subsection{Jinja2} \label{subsec:p;sl;jinja2}
        
        \subsection{jqPlot} \label{subsec:p;sl;jqplot}
        
        \subsection{jVectorMap} \label{subsec:p;sl;jvectormap}
