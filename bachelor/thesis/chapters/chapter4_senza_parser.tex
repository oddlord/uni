\chapter{Da AlViE ad HTML5}
	\label{chap:alvieHTML5}
	Concludiamo questo studio analizzando nel dettaglio come avviene l'esportazione delle visualizzazioni di AlViE in HTML5.\\
	\\
	Come abbiamo visto nel Capitolo \ref{chap:alvie}, AlViE memorizza le visualizzazioni in appositi file XML, che definiscono ogni singolo passo di visualizzazione. Inoltre, sia nel caso in cui l'utente voglia generare una nuova visualizzazione, sia che voglia caricarne una vecchia, il sistema disporrà del file XML corrispondente. Quindi, osservando che la struttura di un file XML e di un file HTML sono molto simili tra loro, per implementare l'esportazione della visualizzazione in HTML5 si è deciso di definire un opportuno compilatore da XML ad HTML5. Questo compilatore XML-HTML5 avrà quindi il compito di tradurre le specifiche della visualizzazione nel file XML in comandi Canvas nel file HTML5.
	\section{Specifica HTML5 delle visualizzazioni}
		Analizziamo innanzitutto come viene strutturata la pagina di visualizzazione HTML5.\\
		\\
		Innanzitutto troviamo, come in tutte le pagine HTML, il tag \lstinline{<html>} che racchiude tutto il codice, e più precisamente i tag \lstinline{<head>} e \lstinline{<body>}. Il tag \lstinline{<head>} contiene il tag \lstinline{<script language="Javascript">}, che definisce appunto uno script in JavaScript, suddiviso in una serie di funzioni. Il tag \lstinline{<body>}, invece, contiene la definizione del Canvas e dei quattro bottoni di navigazione, indicandone l'origine dell'immagine utilizzata, le dimensioni e la funzione JavaScript associata al click su ognuno di essi.\\
		Tramite l'attributo \lstinline{onLoad="start();"}, del tag \lstinline{<body>}, viene richiamata la funzione JavaScript \lstinline{start()}, che permette l'inizializzazione della visualizzazione, disegnando sulla pagina il primo step.\\
		\\
		Ad ogni passo dell'algoritmo corrisponde una funzione JavaScript, della forma
		\begin{center}
			\lstinline{function stepX()},
		\end{center}
		dove X rappresenta il numero del passo di visualizzazione. La funzione relativa al primo passosarà quindi \lstinline{step0()}.\\
		A questo punto, tramite i quattro bottoni di navigazione in cima alla pagina, è possibile spostare la visualizzazione su un altro step. Al click di ogni bottone è associata una funzione JavaScript che calcola la funzione \lstinline{stepX()} da richiamare in base al numero di step attuale e al tipo di funzione richiamata. Le funzioni di navigazione sono quindi quattro, \lstinline{previous()}, \lstinline{next()}, \lstinline{first()} e \lstinline{last()}, che richiamano, rispettivamente, il passo precedente, il successivo, il primo o l'ultimo della visualizzazione. Nel caso in cui la visualizzazione sia sul primo step e venga richiamata la funzione \lstinline{previous()}, un messaggio d'errore verrà visualizzato dal browser. Analogamente per l'ultimo step. Le quattro funzioni di navigazione si avvalgono della funzione \lstinline{eval(str)} per richiamare la giusta funzione di step: questa funzione prende come input una stringa \lstinline{str} e richiama la funzione corrispondente a tale stringa.\\
		\\
		Ogni funzione \lstinline{stepX()} dovrà quindi occuparsi, innanzitutto, di ripulire l'area del Canvas dal passo precedente, tramite la funzione \lstinline{contesto.clearRect(0, 0, canvas.width, canvas.height)}. Dopo aver ripulito l'intero Canvas, verranno richiamate opportune primitive grafiche per produrre il disegno vero e proprio, comprensivo di strutture dati, pseudocodice e messaggio.\\
		Viene anche definita una funzione \lstinline{writeMessage(contesto, messaggio, X)}, con X punto di partenza sull'asse delle ascisse, per poter disegnare sul Canvas il messaggio. È necessaria una funzione a sé stante, in quanto i messaggi più lunghi devono essere spezzati in più linee, che è appunto ciò di cui si occupa la funzione. In caso contrario, messaggi troppo lunghi produrrebbero un'area del Canvas esageratamente lunga, rendendone scomoda la lettura.
	\section{Compilatore XML-HTML5}
		Il compilatore XML-HTML5 che è stato scritto per questo progetto traduce linea per linea il contenuto del file XML della visualizzazione in comandi Canvas da scrivere nella pagina HTML. Vengono quindi aperti due stream (o flussi) dal sistema: uno in lettura dal file XML ed uno in scrittura sul file HTML.\\
		A questo punto inizia la compilazione vera e propria: ogni tag XML ha, all'interno del compilatore, una corrispettiva classe adibita alla gestione di quest'ultimo. Queste classi sono dette \textit{TagHandler}. Ogni volta che il compilatore si imbatte nell'apertura di un nuovo tag, viene invocata la classe \textit{TagHandlerFactory} la quale, implementando il design pattern del \textit{factory}, seleziona il giusto TagHandler per la gestione del tag.\\
		La gestione dei tag avviene quindi, da parte del compilatore, su più livelli, o gerarchie: gestori di livello superiore (o esterni) corrispondono ai tag più esterni del codice XML, come ad esempio \lstinline{<algorithm>} o \lstinline{<step>}; i gestori di livello inferiore corrispondono invece a quei tag situati all'interno di molti altri tag e che solitamente non ne contengono nessun altro, come \lstinline{<element>} o \lstinline{<node>}.\\
		\\
		Il gestore del tag \lstinline{<step>}, ad esempio, si occupa di definire la funzione \lstinline{stepX()} nel file HTML e inserire i comandi per la pulizia del Canvas. Quindi eseguirà un ciclo \textit{while} in cui invoca il TagHandlerFactory, finché non si imbatte nella chiusa del tag \lstinline{<step>}, ovvero \lstinline{</step>}. Una volta usciti dal ciclo \textit{while}, e quindi raggiunta la chiusura del tag, il gestore si occuperà di scrivere le informazioni necessarie alla stampa del messaggio di step sul file HTML.\\
		\\
		I gestori dei tag di tipo \lstinline{<element>}, invece, non effettuano alcuna scrittura sul file, in quanto devono prima essere raccolte informazioni su tutti gli elementi di una struttura dati prima di avere informazioni sufficienti a poter disegnare quest'ultima. Il gestore di questo tipo di tag, quindi, si limita a passare le informazioni, relative all'elemento esaminato, al gestore di livello superiore, che sarà il gestore di un tag di struttura, come \lstinline{<array>}, o \lstinline{<matrix>}.\\
		Una volta ottenute le informazioni necessarie dai tag inferiori, il gestore del tag grafico della struttura (ad esempio \lstinline{<visualArray>}) avrà finalmente tutte le informazioni necessarie per ricavare le primitive grafiche che produrranno il disegno nella pagina HTML.\\
		Spesso però, le informazioni raccolte dai singoli elementi non definiscono in maniera esplicita le operazione grafiche necessarie. Nella specifica XML di un vettore, ad esempio, vengono indicate le coordinate d'origine dell'intero vettore, non di ogni singolo elemento. Tutti questi dati, \textit{impliciti} nella specifica XML, dovranno quindi essere calcolati, tramite apposite funzioni, per poter disegnare nella pagina i singoli elementi grafici che compongono il disegno finale.
		\subsection{Pesantezza della pagina vs. pesantezza di compilazione}
			Ha senso, a questo punto, domandarsi a chi spetta l'onere di calcolare tutti questi dati impliciti. Le scelte sono chiaramente due: il calcolo può essere fatto \textit{a monte}, ovvero dal compilatore, oppure \textit{a valle}, cioè dal browser HTML che visualizza la pagina.\\
			\\
			Se viene scelto di effettuare questi calcoli lato browser, si avrà sicuramente una compilazione più veloce. Il compito del browser verrà, invece, appesantito, rendendosi necessaria l'occupazione di risorse per il calcolo di questi dati impliciti. Questo approccio permette, tuttavia, di riutilizzare il codice necessario alla visualizzazione di stessi oggetti grafici. Può, ad esempio, essere definita una funzione che disegni un quadrato, una che disegni un vettore o una che disegni un intero grafo. Se in una visualizzazione appaiono, ad esempio, più vettori, la visualizzazione di ogni nuovo vettore si tradurrà, nella pagina HTML, in un'unica invocazione della funzione adibita a disegnare vettori.\\
			Quindi questa scelta velocizza il compilatore, rallenta il browser e alleggerisce la pagina.\\
			\\
			Scegliere, invece, di effettuare i calcoli \textit{a monte} implica, chiaramente, un maggio costo computazionale del processo di compilazione. D'altro canto, la pagina HTML verrà alleggerita, per quanto riguarda il costo computazionale, in quanto il compilatore potrà scrivervi direttamente le primitive grafiche necessarie, senza bisogno di ulteriori calcoli. Tuttavia, utilizzare primitive grafiche, all'interno della pagina HTML, significa essere costretti a ripetere il codice necessario al disegno di uno stesso oggetto. Se la visualizzazione deve, ad esempio, disegnare più vettori, ognuno dei quali disegnato da (indicativamente) 10 primitive grafiche, si avranno nella pagina HTML 10 linee di codice per ogni nuovo vettore da visualizzare. Si vede che, rispetto al caso precedente, le dimensioni della pagina risultano aumentate di circa un fattore $m$, dove con $m$ si indica il numero medio di primitive necessarie alla visualizzazione di un oggetto grafico elementare.\\
			Riassumento: questa scelta ci porta ad una compilazione più lenta, una visualizzazione più veloce ed una pagina Web più pesante.\\
			\\
			Non esiste, come si può vedere, una scelta ottimale: le due strade presentano sia pregi che difetti. Quale scelta intraprendere dipende allora dal tipo di applicazione per cui si è reso necessario il compilatore.\\
			Nel nostro caso, ovvero la visualizzazione di algoritmi sul Web, si è ritenuto più efficiente optare per i calcoli dei dati \textbf{a monte}. Si è ipotizzato, infatti, che siano molte di più le volte in cui una visualizzazione venga eseguita (ovvero visualizzare i vari step che la compongono), rispetto alle volte in cui essa possa venir creata (tramite il compilatore) o caricata tramite Internet. Le dimensioni della pagina HTML sono infatti inversamente proporzionali al tempo necessario per il suo download.\\
			Ricapitolando, abbiamo optato, durante lo sviluppo di questo progetto, per una compilazione ed un tempo di download della pagina più lenti, a favore di visualizzazioni più rapide. Questo dilemma risulta, tuttavia, puramente teorico: nella pratica, la scelta di questo metodo al posto dell'altro si riduce ad una manciata di KB in più nella dimensione delle pagine e a pochi millisecondi in più di compilazione. Anche la velocità di visualizzazione da parte del browser risulta praticamente identica. Quindi la scelta è stata presa a livello puramente teorico, in quanto a livello pratico i due metodi sono di fatto indistinguibili.\\
			\\
			Mostriamo, a titolo d'esempio, la funzione che calcola le primitive per il disegno di un cerchio, definita all'interno del compilatore di AlViE:
			\lstinputlisting[language=java]{code/circle.java}
			Si può vedere, in quest'esempio, che il compilatore si occupa di calcolare alcuni dettagli, come il raggio del cerchio o la dimensione del testo all'interno, per poi scrivere sulla pagina HTML le primitive grafiche corrispondenti, come \lstinline{ctx.arc()}.